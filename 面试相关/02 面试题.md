#### 1. 路由传递参数（对象写法）path是否可以结合params参数一起使用?
不可以：不能这样书写，程序会崩掉
路由传参的是，对象写法可以是name，path形式，但是path不能与parmas参数一起使用
#### 2. 如何指定params参数可传可不传? 
```javascript
	{
		name:'search',
		path:'/search:keyword?',
		compontent:Search,
		meta:{show:true}
	}	
```
#### 3.params参数可以传递也可以不传递，但是如果传递是空串，如何解决？
1. 参数可传可不传的写法 在占位符后面加?
```javascript
	routes:[
		{
			path:'/home/id?'
		}
	]
```
2. 空串解决办法加 undefined
```javascript
	this.$router.push({
        name:"search",
        params:{keyword:""||undefined},
        query:{l:this.keyword}
    })
```
#### 4.路由组件能不能传递props数据? 
- 布尔值写法：params
	- props：true
- 对象写法：额外的给路由组件传递一些props
	- props：{ a:1 , b: 2 }
- 函数写法：可以params参数、query参数，通过props传递给路由组件
```javascript
props:($route)=>{
	return {keyword:$route.params.keyword,k:$route.query.k}
}
```
#### 5. 路由跳转有几种方式？
- 声明式导航：**router-link（必须要有to属性）**
- 编程式导航：利用的是组件实例对象的<strong>$router.push|replace</strong>
#### 6.编程式导航路由跳转到当前路由(参数不变), 多次执行会抛出NavigationDuplicated的警告错误?
-  注意:
	- **编程式导航（push|replace）** 才会有这种情况的**异常**
	- **声明式导航是没有这种问题**，因为声明式导航内部已经解决这种问题
	- 这种异常，对于程序没有任何影响的。
- 为什么会出现这种现象:
	- 由于vue-router最新版本3.5.2，引入了promise，当传递参数多次且重复，会抛出异常，因此出现上面现象,
- **第一种解决方案：是给push函数，传入相应的成功的回调与失败的回调
- 第一种解决方案虽然可以暂时解决当前问题，但是以后再用push|replace还是会出现类似现象，因此我们需要从‘根’治病；**（重写push|replace方法）**
```javascript
	//app\src\router\index.js
	//先把VueRouter原型对象的push，先保存一份
	let originPush = VueRouter.prototype.push
	let originReplace = VueRouter.prototype.replace
	
	//重写push|replace
	//第一个参数：告诉原来的push方法，你往哪跳转（传递那些参数）
	//第二个参数：成功的回调
	//第三个参数：失败的回调
	//call||apply区别
	//相同点：都可以调用函数一次，都可以篡改函数的上下文一次
	//不同点：call与apply传递参数：call传递参数用逗号隔开
	VueRouter.prototype.push = function (location, resolve, reject) {
	  if (resolve && reject) {
	    originPush.call(this, location, resolve, reject)
	  } else {
	    originPush.call(
	      this,
	      location,
	      () => {},
	      () => {}
	    )
	  }
	}
	VueRouter.prototype.replace = function (location, resolve, reject) {
	  if (resolve && reject) {
	    originReplace.call(this, location, resolve, reject)
	  } else {
	    originReplace.call(
	      this,
	      location,
	      () => {},
	      () => {}
	    )
	  }
	}

```
#### 7. 为什么需要进行二次封装axios？
1. 统一处理请求和响应
2.  简化了代码
3.  统一管理接口
4.  方便请求网络请求库
	- 请求拦截器：可以再发出请求之前处理一些业务
	- 响应拦截器：当服务器数据返回后，可以处理一些业务
#### 8. 如何进行axios的二次封装？/axios封装的api有哪些？怎么开启跨域？怎么做代理的？配置代理有哪些配置项？
1. 利用axios对象的方法create，去创建一个axios实例
2. 配置请求拦截器和响应拦截器（参考npm官网）
```javascript
‌‌‌　　import axios from 'axios'
‌‌‌　　// 1.利用axios对象的方法create，去创建一个axios实例
‌‌‌　　// 2.request就是axios，只不过稍微配置一下
‌‌‌　　const requests = axios.create({
	  // 配置对象
	  // 基础路径，发请求的时候，路径中会出现API
	  baseURL: '/api',
	  // 代表请求超过的事件5s
	  timeOut: 5000
‌‌‌　　})
‌‌‌　　// 请求拦截器：在发请求之前，请求拦截器可以检测到，可以再请求出去之前做一些事情
‌‌‌　　requests.interceptors.request.use((config) => {
	  if (store.state.detail.uuid_token) {
	    // 请求添加一个字段（userTempId）
	    config.headers.userTempId = store.state.detail.uuid_token
  }
  //需要携带token带给服务器
  if (store.state.user.token) {
    config.headers.token = store.state.user.token
  }
  // config:配置对象，对象里面有一个属性很重要，header请求头
  //进度条开始动
  nprogress.start()
  return config
‌‌‌　　})
‌‌‌　　// 相应拦截器
‌‌‌　　requests.interceptors.response.use(
  (res) => {
    // 成功的回调函数：服务器相应数据回来后，响应拦截器可以检测到，可以做一些事情
    return res.data
  },
  (error) => {
    //响应后失败的回调函数
    //进度条结束
    nprogress.done()
    return Promise.reject(new Error('fail'))
  }
‌‌‌)
‌‌‌export default requests
```
#### 9. webpack代理跨域
- 在vue.config.js文件中配置devServer实现代理转发，从而实现跨域

```javascript 
//Vue.config.js　
module.exports = defineConfig({
  productionSourceMap: false,
  transpileDependencies: true,
  lintOnSave: false,
  //代理跨域
  devServer: {
    proxy: {
      '/api': {
        target: 'http://gmall-h5-api.atguigu.cn'
        // pathRewrite: { '^/api': '' }
      }
    }
  }
‌‌‌})
```

#### 10. nprogress进度条的使用
- 进度条的开始：start() 
- 进度条的结束：done()
- 进度条的颜色可以修改
1. 引入nprogress
2. 在请求拦截器中调用start()方法
3. 在响应拦截器中调用done()方法
```javascript
	//引入进度条
	import nprogress from 'nprogress'
	//start：进度条开始 done：进度条结束
	import 'nprogress/nprogress.css'
	
	const requests = axios.create({
	  // 配置对象
	  // 基础路径，发请求的时候，路径中会出现API
	  baseURL: '/api',
	  // 代表请求超过的事件5s
	  timeOut: 5000
	})
	// 请求拦截器：在发请求之前，请求拦截器可以检测到，可以再请求出去之前做一些事情
	requests.interceptors.request.use((config) => {
	  //进度条开始动
	  nprogress.start()
	  return config
	})
	// 相应拦截器
	requests.interceptors.response.use(
	  (res) => {
	    // 成功的回调函数：服务器相应数据回来后，响应拦截器可以检测到，可以做一些事情
	    return res.data
	  },
	  (error) => {
	    //响应后失败的回调函数
	    //进度条结束
	    nprogress.done()
	    return Promise.reject(new Error('fail'))
	  }
	)
	export default requests

```
#### 11.vuex
- context【小仓库】
- commit【提交mutations修改state】 
- getters【计算属性】
- dispatch【派发action】
- state【当前仓库数据】
- module：将仓库分成更小的模块，每个模块都拥有自己的store、mutation、action、getter
```javascript
‌‌‌　　import Vue from 'vue'
‌‌‌　　import Vuex from 'vuex'

‌‌‌　　Vue.use(Vuex)
‌‌‌　　// //state：仓库存储数据的地方
‌‌‌　　const state = {}
‌‌‌　　// // mutations:修改state的唯一手段
‌‌‌　　const mutations = {}
‌‌‌　　// // action:处理action的地方，可以书写自己数据逻辑，也可以处理异步
‌‌‌　　const action = {}
‌‌‌　　// // getters: 理解为计算属性，用于简化仓库的数据，让组件获取仓库中的数据更加方便
‌‌‌　　const getter = {}
‌‌‌　　//对外暴露store类的一个实例
‌‌‌　　export default new Vuex.Store({
  //实现Vuex仓库模块化开发存储数据
  modules: {
  }
‌‌‌　　})

```
#### 12. 防抖与节流（lodash插件解决）
- 防抖(\_.debounce)：
	- 前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次

- 解决防抖(\_.debounce）
```javascript
‌‌‌　　input.oninput=_.debounce(function(){
	console.log('ajax发请求')//一秒后发请求
‌‌‌　　},1000)
```

- 节流(\_.throttle)：闭包+延迟器
	- 在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发(用户多次操作，把频繁触发变为少量触发）
	
-  解决节流(\_.throttle)
```javascript
‌‌‌　　changeIndex: throttle(function (index) {
      //index：鼠标移上某一个一级分类元素的索引值
      this.currentIndex = index
    }, 50),
```
- 注意：throttle不能用箭头函数，可能会出现上下文this问题
- 防抖: 用户操作很频繁，但是只是执行一次
- 节流: 用户操作很频繁，但是把频繁的操作变为少量操作

#### 13:三级联动路由跳转以及传递参数
```javascript
‌‌‌　　//进行路由跳转的回调函数
    goSearch(event) {
      //event.target:获取到的是出发事件的元素(div、h3、a、em、dt、dl)
      let node = event.target
      //给a标签添加自定义属性data-categoryName,全部的字标签当中只有a标签带有自定义属性，别的标签名字----dataset纯属扯淡
      let { categoryname, category1id, category2id, category3id } = node.dataset
      //第二个问题解决了：点击的到底是不是a标签（只要这个标签身上带有categoryname）一定是a标签
      //当前这个if语句：一定是a标签才会进入
      if (categoryname) {
        //准备路由跳转的参数对象
        let loction = { name: 'search' }
        let query = { categoryName: categoryname }
        //一定是a标签：一级目录
        if (category1id) {
          query.category1Id = category1id
          //一定是a标签：二级目录
        } else if (category2id) {
          query.category2Id = category2id
          //一定是a标签：三级目录
        } else {
          query.category3Id = category3id
        }
        //判断：如果路由跳转的时候，带有params参数，捎带脚传递过去
        if (this.$route.params) {
          loction.params = this.$route.params
          //动态给location配置对象添加query属性
          loction.query = query
          //路由跳转
          this.$router.push(loction)
        }
      }
    }
```
#### 14:如何合并query参数和param参数
1. 先判断有没有query参数
2. 在创建一个location来接受name和params
3. 再将query参数赋值给location
4. 最后在调用$router.push方法
```javascript
 if (this.$route.query) {
        let location = {
          name: 'search',
          params: { keyword: this.keyword || undefined }
        }
        location.query = this.$route.query
        this.$router.push(location)
      }
```
#### 15. 如何通过mock.js模拟假数据
1. 安装依赖包mockjs
2. 在src文件夹下创建一个文件夹，文件夹mock文件夹。
3. 准备模拟的数据
	- 把mock数据需要的图片放置于public文件夹中！
	- 比如:listContainer中的轮播图的数据
``` javascript
	[
	   {id:1,imgUrl:'xxxxxxxxx'}, 
	   {id:2,imgUrl:'xxxxxxxxx'}, 
	   {id:3,imgUrl:'xxxxxxxxx'}, 
	]
```
4. 在mock文件夹中创建一个server.js文件
	注意：在server.js文件当中对于banner.json||floor.json的数据没有暴露，但是可以在server模块中使用。
	‌‌‌对于webpack当中一些模块：图片、json，不需要对外暴露，因为默认就是对外暴露。
5. 通过Mock.mock方法进行模拟数据
6. 回到入口文件，引入serve.js
	‌‌‌mock需要的数据|相关mock代码页书写完毕，关于mock当中serve.js需要执行一次，
	‌‌‌如果不执行，和你没有书写一样的。
7.  在API文件夹中创建mockRequest【axios实例：baseURL:'/mock'】
	专门获取模拟数据用的axios实例。
#### 16.轮播图[swiper](https://www.swiper.com.cn/usage/index.html)的使用
1. 在 HTML 文件中引入 Swiper 的 CSS 和 JavaScript 文件
2. 在 HTML 文件中创建一个容器元素，用于包含轮播图
3. 在 JavaScript 文件中初始化 Swiper，以及配置轮播图的参数等等。
#### 17. nextTick
- nextTick官网解释:
	**在下次DOM更新, 循环结束之后,执行延迟回调。**在 修改数据之后 立即使用这个方法，获取更新后的DOM 。
- 注意：组件实例的$nextTick方法，在工作当中经常使用，**经常结合第三方插件使用，获取更新后的DOM节点。**
- 使用场景：
	1. 在修改数据之后，立即获取更新后的dom元素
	2. 使用$ref访问子组件的dom元素，由于还没创建，可以使用nextTick访问子组件的dom元素
	3. 使用第三方UI库
#### 18. 如何合并参数
- Object.assign(target, ...sources)
- 参数:
	- target--->目标对象
	- source--->源对象
	- 返回值：target，即目标对象
#### 19. 了解哪些 Vue 的性能优化方法？
- 路由懒加载。有效拆分应用大小，访问时才异步加载。
- keep-alive缓存页面。避免重复创建组件实例，且能保留缓存组件状态。
- v-for遍历避免同时使用v-if。实际上在 Vue 3 中已经是一个错误用法了。
- 长列表性能优化，可采用虚拟列表。
- v-once。不再变化的数据使用v-once。
- 事件销毁。组件销毁后把全局变量和定时器销毁。
- 图片懒加载。
- 第三方插件按需引入。
- 子组件分割。较重的状态组件适合拆分。
- 服务端渲染。
#### 20. Vue项目性能优化？
- 一.代码层面优化
	1. 利用v-if 和v-for减少初始化渲染和切换渲染的性能开销
	2. computed.watch.methods区分使用场景
	3. 提前处理好数据解决v-if和v-for必须同级的问题
		- 因为当Vue处理指令时，v-for比v-if具有更高的优先级，意味着v-if 将分别重复运行于每个v-for循环中。
	4. 给v-for循环项加上key提高diff计算速度
	5. 利用v-once处理只会渲染一次的元素或组件
	6. 利用Object.freeze()冻结不需要响应式变化的数据
	7. 提前过滤掉非必须数据，优化data选项中的数据结构
	8. 避免在v-for循环中读取data中数组类型的数据
	9. 防抖和节流
	10. 图片大小优化和懒加载
	11. 利用挂载节点会被替换的特性优化白屏问题
	12. 组件库的按需引入
- 二.项目打包优化
	1. 利用import()异步引入组件实现按需引入
	2. 利用externals提取第三方依赖并用CDN引入
	3. 利用SplitChunks插件提取公共js代码和分割js代码
	4. 利用MiniCssExtractPlugin插件提取css样式
	5. 利用OptimizeCssnanoPlugin插件压缩和去重css样式文件
	6. 开启optimization.minimize来压缩js代码
	7. 利用image-webpack-loader进行压缩图片
- 三.项目部署优化
	1. 识别gzip压缩是否开启
	2. 在Nginx上开启gzip压缩
	3. 在Webpack上开启gzip压缩
	4. Nginx和Webpack压缩的区别
	5. CompressionPlugin插件的参数详细详解
###### 总结部分：
- 一.代码层面优化
	1. 利用v-if和v-for减少初始化渲染和切换渲染的性能开销
	2. 避免v-for遍历的同时使用v-if
	3. 不在变化的数据使用v-once
	4. 防抖与节流
	5. 图片懒加载
- 二.项目打包优化
	1. 利用import（）异步引入组件实现按需引入(路由懒加载)
	2. 第三方组件库按需引入
	3. 利用image-webpack-loader进行压缩图片 
#### 21.typeof和instance of的区别
- typeof：判断变量的数据类型，返回的是一个字符串
- instanceof：判断一个变量是否属于某个对象的实例
#### 22.js基本数据类型
null、undefined、boolean、string、number、bigint
#### 23. typeof (null) 是什么
返回的是object，但是这是一个bug
#### 24. 如何实现深拷贝
1. 使用JSON.Stringify（JSON.parse（obj1）），但是不支持多层引用嵌套，Map、Sep函数
2. 递归（使用循环一层一层的进行拷贝）
#### 25.如何创造一个没有原型的对象
- Object.create(proto,[propertiesObject])
	- proto:新创建的原型对象
	- propertiesObject：可选
#### 26.用过扩展运算符吗? 是深拷贝还是浅拷贝?
- 浅拷贝
#### 27.call、bind、apply 的区别?
1. 相同点
	- 三个都是用于改变this指向；
	- 接收的第一个参数都是this要指向的对象；
	- 都可以利用后续参数传参。
2. 不同点
	- call和bind传参相同，多个参数依次传入的；
	- apply只有两个参数，第二个参数为数组；
	- call和apply都是对函数进行直接调用，而bind方法不会立即调用函数，而是返回一个修改this后的函数。
#### 28.闭包
- 什么是闭包？
	- 闭包是可以访问其他函数内部变量的函数
- 触发闭包的情况？
	1. 函数当做返回值被返回
	2. 函数被当做参数被传递
- 闭包的应用？
	1. 隐藏变量
	2. 封装变量和方法
	3. 延迟执行
	4. **创建私有变量**
	5. **延长变量的生命周期**
#### 29.computed和watch的区别
- computed默认是走缓存，不支持异步，只依赖数据发生变化才会重新计算
- watch不依赖缓存，支持异步，一旦数据发生变化就直接触发相应操作
#### 30.解决跨域问题的方法：
- 配置nginx反向代理
- 使用jsonp方式（script方式）
- 使用图片
- 设置CORS（跨域资源共享）
- 利用iframe实现
- WebSocket
#### 31.说说封装组件的思路
- 视图层面，相似度高的视图进行进行一个封装，提供部分参数方便使用者修改。
- 对于业务复用度较高的，提取出业务组件。
#### 32.一次请求大量数据怎么优化，数据多导致渲染慢怎么优化
- 一次请求大量数据怎么优化？
	1. 分页加载：将数据按照一页一页的方式进行加载，每次只加载一页数据，这样可以减少单次请求的数据量，提高页面的渲染速度。
	2. 懒加载：只在用户需要时才加载数据，例如在滚动到页面底部时再加载下一页数据，这样可以减少不必要的数据请求，提高页面的响应速度。
	3. 数据缓存：将数据缓存在客户端本地，下次访问时直接从缓存中读取数据，避免重复请求，提高页面的加载速度。
	4. 数据压缩：对请求的数据进行压缩，减小数据传输的大小，从而提高网络传输速度。
	5. 数据分离：将页面和数据分离，使用 AJAX 技术异步加载数据，避免页面的重复刷新，提高页面的响应速度。
- 数据多导致渲染慢怎么优化？
	1. 减少页面元素数量：减少页面中不必要的元素数量，例如移除不必要的图片、视频等元素，从而减少渲染时间。
	2. 减少 DOM 操作：DOM 操作是非常耗费性能的操作，应该尽量减少 DOM 操作的次数，例如使用文档片段（DocumentFragment）和虚拟 DOM（Virtual DOM）等技术来减少 DOM 操作的次数。
	3. 使用 CSS3 动画：使用 CSS3 动画可以在浏览器端完成动画效果，避免了 JavaScript 操作 DOM 的过程，从而提高页面的渲染速度。
	4. 图片优化：对图片进行优化，例如压缩图片大小、使用合适的图片格式等，从而减小图片的加载时间。
	5. 避免阻塞渲染的 JavaScript 代码：JavaScript 代码会阻塞页面的渲染，应该尽量避免编写阻塞渲染的 JavaScript 代码，例如将 JavaScript 代码放在页面底部、使用异步加载 JavaScript 代码等。
#### 33.http缓存
- 分为强缓存和协商缓存
	1. 首先通过Cache-Control验证强缓存是否可用，如果可用，则直接读取缓存
	2. 如果不可以，那么进入协商缓存，发起HTTP请求，服务器会通过请求头中是否带上Etag / If-None-Match这些条件请求字段检查资源是否更新
	   - 若资源更新，那么返回资源和200状态码
	   - 若未更新，那么返回304并告诉浏览器直接使用缓存获取资源
#### 34.数组去重
1. 使用es6提供的new set（）
```javascript
var arr=[1,3,5,6,7,78,78,78,8,9,8]

function noRepeat(arr){
	var newArr = [...new Set(arr)];//利用Set结构不能接受重复数据的特点
	return newArr
}
var arr2 = noRepeat(arr)
console.log(arr2)
```
2. 利用for循环+indexOf（）
```javascript
var arr=[1,3,5,6,7,78,78,78,8,9,8]
console.log(arr)
function noRepeat(arr){
	var newArr = [];
	for(var i=0;i<arr.length;i++){
		//indexOf()判断数据中有没有字符串，如果没有则返回-1
		if(newArr.indexOf(arr[i] === -1){
			newArr.push(arr[i]);
		})
	}
	return newArr
}
var arr2 = noRepeat(arr)
console.log(arr2)
```
3. 双重for循环
```javascript
var arr=[1,3,5,6,7,78,78,78,8,9,8]
console.log(arr)
function noRepeat(arr){
	for(var i=0;i<arr.length;i++){
		for(var j=0;j<arr.length;j++){
			if(arr[i] == arr[j] && i != j){
				arr.splice(j,1)
			}
		}
	}
	return arr;
}
var arr2 = noRepeat(arr)
console.log(arr2)
```
#### 35.[跨域 ](https://blog.csdn.net/m0_37873510/article/details/126558023)
- 什么是跨域？
	- 跨域是当页面发送ajax请求时，协议、域名、端口号必须一致。
		
- 解决跨域的五种方式？
	1. JSONP方式解决跨域
	2. cros方式解决跨域
	3. 搭建Node代理服务器解决跨域
	4. Nginx反向代理解决跨域
	5. postMessage方式解决跨域
#### 36.for in和for of 的区别
1. for in 遍历的数组下标，for of遍历的数组的值
2. for in一般用于遍历对象，for of遍历数组
#### 37.ES6 [Promise](https://blog.csdn.net/qq_34645412/article/details/81170576)用法小结
- 什么是Promise？
	- Promise是异步变成的一种解决方案，是一个构造函数，有all()、reject()、resolve()方法，原型上有then()、catch等方法
#### 38.css中的排序
- order和z-index
```css
ul li:nth-chile(3){
	order:-1;
}

a{
	z-index:1;
}
b{
	z-index:2;
}
```
- order用于控制元素的顺序，它的值是一个整数，数值越小，元素越靠前。
- order只能用于flex布局中的子元素，而z-index只对定位元素（position为relative、absolute或fixed）起作用
#### 39.splice的参数
- index：从那个元素开始删除
- howmany：要删除几个元素
- item1, …, itemX ：向数组中添加的新元素
- 返回值：Array
#### 40.[伪类和伪元素](https://www.w3school.com.cn/css/css_pseudo_elements.asp)
- 什么是伪类？
	- 伪类用于定义元素的特殊状态。
	- 应用:
		1. 设置鼠标悬停在元素上时的样式
		2. 为已访问和未访问链接设置不同的样式
		3. 设置元素获得焦点时的样式
- 什么是伪元素？
	- 伪元素用于设置元素指定部分的样式。
	- 应用：
		1. 设置元素的首字母、首行的样式
		2. 在元素的内容之前或之后插入内容
#### 41.前端和后端交接工作的时候具体要做的事？
##### 1. 接口及数据格式确定
‌‌‌　　在前后端交接时，需要确认前端需要访问的接口及接口的参数、返回数据格式等。在此之前，前端和后端需要进行沟通，确定接口设计方案，并在接口文档中进行记录，以便后续调用。在接口设计方案确定后，需要进行接口测试，确保接口能够正常工作。
##### 2. 版本控制与代码交接
‌‌‌　　前后端代码都需要进行版本控制，常使用 Git 进行管理。在前后端交接时，需要将最新的代码提交到主仓库，并确保前后端代码是同一个版本。若前后端代码不在同一仓库，则需要将前端代码和文档等相关资料打包交付给后端。
##### 3. 部署与运维
‌‌‌　　前后端交接之后，需要部署到测试环境，进行测试验证。测试通过后才能部署到线上环境。在部署时需要注意相关配置、文件权限等问题。部署后，需要进行持续监控，确保线上环境的稳定运行。	
##### 4. 知识传递与技术支持
‌‌‌　　前后端交接后，需要进行相关知识和技术的传递和支持。如果后端遇到前端相关问题，前端需要提供技术支持和解决方案；如果前端遇到后端相关问题，后端需要提供解决方案和技术支持。
#### 42.Vue 项目的迭代更新流程
1. 从需求中拆分出任务
	-  根据需求，将任务拆分成较小的、可实现的代码任务。可以使用类似 JIRA、Trello 等项目管理工具来管理开发任务。
2. 创建分支
	- 将当前代码库的代码拉取到本地，并新建一个分支来处理当前任务。在此分支上进行开发、提交代码和合并分支。
3. 编写代码并提交
	- 在本地环境中编写代码，并使用 Git 等工具提交代码到分支。一般情况下，提交代码后需要进行 Code Review，确保代码的质量。
4. 对代码进行测试
	- 在本地环境中对提交的代码进行测试，确保代码能够正常工作，并没有引入新的问题。可以使用 Jest 等测试框架进行单元测试。
5. 合并分支
	- 经过测试后，可将本地的代码推送到远程仓库，然后在 Git 等工具上进行合并，将当前分支的代码合并到主干上，释放当前任务的代码。
6. 进行上线测试
	- 将当前分支合并到主干后，需要进行上线测试，确保该次迭代更新不影响现有功能的正常使用。
7. 监控反馈和修复问题
	- 在上线后尽可能的全面监控应用的情况，及时发现和修复问题，并以用户反馈为依据，进行下一次迭代更新
#### 43.在前端开发过程中发现接口文档缺少某些接口或者接口参数
1. 了解情况
	- 首先，了解接口缺失的具体情况，比如缺失的接口名称、参数、返回数据格式等。这些信息有助于你发现问题的根本原因，并向后端提供明确的反馈。
2. 与后端沟通
	- 与后端通过即时通信工具或者邮件等方式进行沟通，向后端表明接口文档缺失对项目开发的影响，并尽可能清晰地描述需要新增或者补充的接口及其细节。
3. 提出解决方案
	- 在与后端沟通的同时，提出解决方案，比如设计新的接口、修改已有的接口或者制定参数等。并向后端说明具体实现方式和需要考虑的因素等。
4. 确认方案
	- 与后端确认协商的方案，协商后一定需要与后端保持沟通，确保双方的理解是一致的。
5. 进行测试
	- 新增或者修改接口后，还需要进行相应的测试，保证新增的或者修改的接口能够正常工作。
#### 44.vue原型链上的set方法
1. 更新数组中某个索引对应的值
2. 给对象添加新属性，并保证该属性是响应式的
#### 45.css样式冲突如何解决
1. 提高选择器的优先级
	- 内联样式 > ID 选择器 > 类选择器、属性选择器和伪类选择器 > 元素选择器和伪元素选择器。
2. 使用层叠样式表（CSS） @规则
3. 使用 !important 关键字
4. 使用特殊的 CSS 类或 ID
5. 修改 HTML 结构
#### 46.在那个生命周期可以获取dom元素 
- mounted和updated
#### 47.微前端
‌‌‌　　微前端（Micro Frontends）是一种新的前端架构模式，它**将一个大型的前端应用拆分成多个小型子应用，每个子应用都可以独立开发、测试、部署和运营。每个子应用都有自己的前端技术栈和独立的代码仓库，可以使用不同的框架（如 React、Vue、Angular 等）来开发子应用。**

‌‌‌　　微前端的基本原理是将每个子应用作为独立的模块运行，通过一个主应用来加载子应用，从而实现多个子应用的组合和协同工作。每个子应用可以有自己的路由、状态管理、样式等，与其他子应用之间相互隔离，不影响彼此的业务逻辑。

微前端架构模式的优势：
1. 代码解耦：每个子应用具有独立的仓库和构建过程，彼此之间可以相互独立，不影响整体应用的部署和扩展。
2. 技术栈多样：每个子应用可以使用不同的前端框架和技术栈，不需要局限于整个应用的技术栈，具有更大的灵活性和自由度。
3. 部署简单：每个子应用都可以独立部署，不需要整个应用都重新打包发布，可以更加快速地迭代应用。同时，也可避免因整个应用发布而导致的宕机和问题。
4. 独立运行：子应用与主应用之间相互隔离，不会因子应用的故障或崩溃而影响整个应用的安全性和稳定性。
#### 48.事件循环Event Loop 
1. JS是单线程,防止代码阻塞，我们把代码(任务) :同步和异步
2. 同步代码给js引擎执行，异步代码交给宿主环境
3. 同步代码放入执行栈中，异步代码等待时机成熟送入任务队列排队
4. 执行栈执行完毕，会去任务队列看是否有异步任务，有就送到执行栈执行，反复循环查看执行，这个过程是事件循环(eventloop)

‌‌‌　　JavaScript用于实现异步编程的机制，可以将异步事件加入到事件队列中，然后在主线程空闲时，依次从事件队列中取出事件并执行，从而实现异步事件的处理。

‌‌‌　　事件循环机制分为**宏任务和微任务**两个阶段，宏任务包括整体代码、定时器、网络请求等，而微任务包括 Promise 的 then 方法、async/await 函数等。

‌‌‌　　**当主线程执行完一个宏任务后，会检查微任务队列是否有任务需要执行，如果有，则依次执行所有微任务，然后再执行下一个宏任务，依次循环，直到所有任务都执行完毕。**
#### 49.[nodejs](https://xie.infoq.cn/article/93c2e9c67a82d84a3ead02464)里面fs模块和path模块
- fs 文件系统模块：用来操作文件的模块。
- path 路径模块：用来处理路径的模块。
#### 50.www.a.com和a.com的cookie能共享吗？
- 不能共享，他们被视为两个不同的域名。
#### 51.如何在设置cookie时指定父域名？
- 在设置cookie时，可以使用**domain**属性来指定cookie的父域名。如果不指定domain属性，则cookie的父域名默认为当前页面的域名。
```html
document.cookie = "name=value; domain=example.com; path=/";
```

#### 52.Node + js实现[大文件分片上传](https://www.cnblogs.com/tugenhua0707/p/11246860.html)基本原理及实践
- 分片上传是把一个大的文件分成若干块，一块一块的传输。这样做的好处可以减少重新上传的开销。
- 实现文件分片上传的步骤如下：
	1. 先对文件进行md5加密。使用md5加密的优点是：可以对文件进行唯一标识，同样可以为后台进行文件完整性校验进行比对。
	2. 拿到md5值以后，服务器端查询下该文件是否已经上传过，如果已经上传过的话，就不用重新再上传。
	3. 对大文件进行分片。比如一个100M的文件，我们一个分片是5M的话，那么这个文件可以分20次上传。
	4. 向后台请求接口，接口里的数据就是我们已经上传过的文件块。(注意：为什么要发这个请求？就是为了能续传，比如我们使用百度网盘对吧，网盘里面有续传功能，当一个文件传到一半的时候，突然想下班不想上传了，那么服务器就应该记住我之前上传过的文件块，当我打开电脑重新上传的时候，那么它应该跳过我之前已经上传的文件块。再上传后续的块)。
	5. 开始对未上传过的文件块进行上传。(这个是第二个请求，会把所有的分片合并，然后上传请求)。
	6. 上传成功后，服务器会进行文件合并。最后完成。
- 注意：**blob.slice() 方法对二进制的Blob对象进行切割**
#### 53.[md5加密](https://betheme.net/qianduan/98164.html)
- 可以对文件进行唯一标识，同样可以为后台进行文件完整性校验进行比对。
#### 54.[网页卡顿的原因](https://www.jianshu.com/p/841e0df0be91)
1. 渲染不及时，页面掉帧
	- 长时间占用js线程
	-  页面回流和重绘较多
	-  资源加载堵塞
2. 网页内存占用过高，运行卡顿
	- 意外的全局变量引起的内存泄漏
	- 闭包引起的内存泄漏
	- 被遗忘的定时器
	- 循环引用
	- DOM 删除时没有解绑事件
	- 没有清理的DOM元素引用
#### 55.接手一个项目最先做什么
1. 阅读项目文档：了解项目的需求、业务流程、技术实现等信息，同时也可以了解项目的整体结构和模块划分，为后续的开发工作打下基础。
2. 研究项目代码：通读项目的代码，了解项目的整体结构和代码风格，同时也可以了解项目使用的技术栈、框架和库等信息。
3. 运行项目：在本地环境中运行项目，查看项目的运行效果和功能实现情况，同时也可以了解项目的开发环境和部署方式等信息。
4. 调试和优化：对项目进行调试和优化，查找并修复已知的问题和bug，同时也可以对项目的性能和用户体验进行优化。
5. 提出建议和改进：在了解项目的基础上，可以提出自己的建议和改进意见，为项目的后续开发和维护提供帮助。

#### 56.变量提升
- 变量提升通常发生在 var 声明的变量里，使用var声明一个变量时，该变量会被提升到作用域的顶端，但是赋值的部分并不会被提升。
- 函数声明和变量声明都会被提升，但是需要注意的是函数会先被提升，然后才是变量。
#### 57.函数柯里化
- 函数柯里化是一种将接受多个参数的函数转换为一系列接受单个参数的函数的技术。通过函数柯里化，我们可以将一个函数的分解为多个部分，每个部分都可以单独传递，从而使函数更加灵活和可重用。
- 通常来说，输出日志，一般当天日期是不变的，同一个项目的项目名也是不变的（不过不同的项目名是变化的），唯有信息是时刻变化，那么我们可以将日期这个参数存储起来，这样就不用每次都传日期；当遇到同一个项目的时候，也可以把项目名这个参数存起来，不用每次都传项目名；接下来调用只需要传信息这个参数即可。
#### 58.如何实现全局对按钮的权限设定，用户看不到自己没有权限的按钮
1. 在后端服务器中，为每个用户分配一个角色，并将每个角色与一组权限关联起来。例如，角色可以访问所有按钮，而普通用户角色只能访问部分按钮。
2. 在前端应用程序中，使用一个全局的权限管理器来管理用户的权限。该权限管理器可以在用户登录时从后端服务器获取用户的角色和权限信息，并将其存储在本地存储中。
3. 在每个按钮组件中，使用该权限管理器来检查当前用户是否有访问该按钮的权限。如果用户没有权限，则隐藏该按钮。
#### 59.如何保留小数点后两位
- 保留小数点后两位可以使用 JavaScript 中的内置方法 **toFixed()**。
- toFixed() 方法可以将数字四舍五入到指定的小数位数，并将其作为字符串返回。
#### 60.axios如何取消队列
- 在使用 Axios 发送请求时，可以通过**CancelToken** 来实现取消请求。
```javascript
//创建CancelToken对象
const source = axios.CancelToken.source();

//发送请求
axios.get('/api/data',{
	cancelToken:source.token
}).then(response => {
	//处理响应
}).catch(error => {
	//处理错误
	if(axios.isCancel(error)){
		console.log('请求已取消',error.message)
	}else{
		console.log('请求失败',error.message)
	}
})

//取消请求
source.cancel('用户取消请求');
```
#### 61.git冲突如何解决
1. **获取最新的代码**：在本地仓库中执行 **git fetch** 命令，获取远程仓库中最新的代码。
2. **合并代码**：在本地仓库中执行 **git merge** 命令，将远程仓库中最新的代码合并到本地仓库中。
3. 解决冲突：当 Git 合并代码时，如果发现冲突，就会在冲突文件中标记出冲突的位置。需要手动编辑冲突文件，将冲突的部分修改为正确的内容。通常情况下，Git 会使用 <<<<<<<、======= 和 >>>>>>> 标记出冲突的位置，开发者需要将这些标记删除，并保留正确的代码。
4. **提交修改：在本地仓库中执行 git add 命令，将修改后的文件添加到暂存区中。然后执行 git commit 命令，提交修改。**
5. **推送代码**：在本地仓库中执行** git push **命令，将修改后的代码推送到远程仓库中。
#### 62.同步执行和异步执行在同一页面，如何执行？
‌‌‌　　所有同步执行结束之后，异步才开始执行
#### 63.Map与Set
- ##### Map：以键值对的形式存在，允许任何类型的键
- 一、方法以及属性：
	1. new Map() —— 创建 map。
	2. map.set(key, value) —— 根据键存储值。
	3. map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。
	4. map.has(key) —— 如果 key 存在则返回 true，否则返回 false。
	5. map.delete(key) —— 删除指定键的值。
	6. map.clear() —— 清空 map。
	7. map.size —— 返回当前元素个数。
- 二、应用场景：
	- 缓存数据
	- 实现字典
	- 实现计数器
##### Set： 是一组唯一值的集合。
- 一、方法和属性：
	1. new Set([iterable]) —— 创建 set，可选择带有 iterable（例如数组）来进行初始化。
	2. set.add(value) —— 添加一个值（如果 value 存在则不做任何修改），返回 set 本身。
	3. set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。
	4. set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。
	5. set.clear() —— 清空 set。
	6. set.size —— 元素的个数。
- 二、应用场景
	- 数组去重
	- 判断元素是否存在
#### 64.es6新增特性
- let和const
- Symbol
- 解构赋值
- Map和Set
- 箭头函数
- promise异步
#### 65.let、const、var区别，以及在let上方打印定义的属性，会发生什么，报什么错误？
- 什么是变量提升？
	- 变量能在声明之前使用，就是变量提升。
- var可以重复声明变量，不存在块级作用域，可以变量提升
- let是块级作用域，能改变指针指向
- const是块级作用域，必须设置初始值，常用做常量

- 在let上方打印定义的属性，会发生什么，报什么错误？
	- 如果在 let 声明语句之前打印该变量，会报 ReferenceError 错误，提示该变量未定义。
#### 66.[h5离线缓存技术](https://blog.csdn.net/qq_44783283/article/details/107772055)
- 离线缓存技术需要使用 **cache manifest** 文件来指定需要缓存的资源。
1. 创建一个缓存清单文件（manifest file），该文件包含您想要缓存的所有文件的列表。该文件应该是一个简单的文本文件，其中包含每个文件的相对路径。

2. 在HTML文档的头部添加一个manifest属性，该属性指向您创建的缓存清单文件。例如：

``` javascript
   <html manifest="example.appcache">
```

3. 在缓存清单文件中，使用CACHE部分来列出您想要缓存的文件。例如：

```javascript
   CACHE MANIFEST
   # Version 1.0.0

   /index.html
   /styles.css
   /script.js
```

4. 在缓存清单文件中，使用NETWORK部分来列出您不想缓存的文件。例如：

```javascript
   NETWORK:
   *

   # Exclude these files from the cache
   /api/*
   /login
```

5. 在缓存清单文件中，使用FALLBACK部分来指定当离线时应该使用的备用资源。例如：

``` javascript
   FALLBACK:
   /offline.html
 ```

6. 在JavaScript中，使用**applicationCache**对象来检查缓存状态并更新缓存。例如：

```javascript
   var appCache = window.applicationCache;

   appCache.update();

   appCache.addEventListener('updateready', function() {
     if (appCache.status == window.applicationCache.UPDATEREADY) {
       appCache.swapCache();
       console.log('App cache updated');
     }
   }, false);
```
**注意：**
- **缓存清单文件必须在Web服务器上托管，并且必须使用正确的MIME类型（text/cache-manifest）。此外，缓存清单文件中列出的所有文件都必须在同一域中托管。**
#### 67.promise.then的第二个参数
- Promise.then有两个参数，一个是处理成功的回调函数，另一个是处理失败的回调函数。
- 第二个参数是可选的，如果省略了第二个参数，则在 Promise 被拒绝时会抛出一个未处理的异常。
- 如果指定了第二个参数，则可以捕获 Promise 被拒绝时的异常，并进行相应的处理。
#### 68.组件的样式如何修改？
1. **使用组件库提供的主题定制工具**：一些组件库（例如 Ant Design、Element UI 等）提供了主题定制工具，可以通过修改主题变量或样式文件来修改组件库的样式。这种方式比较简单，但是只能修改一些预定义的样式变量或样式类，不能进行细粒度的样式修改。
2. **使用css选择器全局样式覆盖**：可以在全局样式文件中使用 CSS 选择器来覆盖组件库的样式。这种方式比较灵活，可以进行细粒度的样式修改，但是可能会影响到其他组件或页面的样式。
3. **使用scoped局部样式覆盖**：可以在组件内部使用 scoped 样式或 CSS Modules 来覆盖组件库的样式。这种方式比较安全，不会影响到其他组件或页面的样式，但是需要对每个组件进行样式修改，比较繁琐。
4. 修改组件库源码：如果以上方法都不能满足需求，可以直接修改组件库的源码。这种方式可以进行任意的样式修改，但是需要对组件库的源码进行深入了解，并且需要维护自己的修改，可能会导致升级困难等问题。
#### 69.数据是多重对象或数组，改变数据后页面不更新
1. 使用Vue.set()或this.set更新数据
2. 使用深拷贝JSON.parse(JSON.stringify(data))更新数据
#### 70.async和await怎么捕获异常
- 使用try…catch捕获异常
#### 71.vue视图变化了，数据也更新了，但是页面没渲染
1. 数据更新不是响应式的：Vue 只能响应对象和数组的变化，如果直接修改了一个属性或元素，而没有使用 Vue 提供的响应式方法（例如 $set、$delete 等），那么数据变化就不会被 Vue 监测到，也就不会触发视图更新。
2. 数据更新时没有触发更新：Vue 在更新视图时会对数据进行浅层比较，如果数据的引用没有变化，就不会触发更新。如果数据变化后，没有触发更新，可能是因为数据的引用没有变化，或者数据的属性被修改了，但是没有触发更新。
3. 异步更新导致的问题：在 Vue 中，异步更新是常见的操作，例如在 nextTick 中更新数据、在 setTimeout 中
#### 72.登录和权限是怎么实现的
1. 登录：用户在登录页面输入用户名和密码，通过 axios或其他网络请求库向后端发送登录请求，后端根据用户名和密码验证用户身份，并返回一个包含用户信息和 token 的响应。
	- 前端将 token 存储在本地，通常使用 localStorage 或 sessionStorage存储。
2. 权限：前端在每次请求后端接口时，都需要将存储在本地的 token 发送给后端进行验证。后端通过解析 token，验证用户身份和权限，并返回相应的数据或错误信息。前端根据后端返回的数据或错误信息，进行相应的处理。例如，如果用户没有权限访问某个页面或接口，前端可以跳转到登录页面或提示用户没有权限。
#### 73.this规则的优先级
- this的指向，是在执行函数时根据执行上下文所动态决定的。
- （调用函数会创建新的属于函数自身的上下文，执行上下文的调用创建阶段会决定this的指向。）
- 一般来说，this 绑定的优先级： new > 显示绑定 > 隐式绑定 > 默认绑定。
#### 74.为什么要用深拷贝
1. 对象或数组作为函数参数传递时，**为了避免修改原对象或数组**，可以使用深拷贝将对象或数组复制一份。
2. 对象或数组作为状态管理工具（如 Vuex）的状态时，**为了避免多个组件之间共享同一个对象或数组**，可以使用深拷贝将状态复制一份。
3. 对象或数组作为缓存时，**为了避免缓存对象或数组被修改**，可以使用深拷贝将缓存数据复制一份。
#### 75.如果不进行跨域配置，服务器会接收到请求吗？
- 服务器通常会接收到请求，但是浏览器会拦截服务器的响应，因为浏览器会执行同源策略（Same-Origin Policy），禁止跨域访问其他域名下的资源。
#### 76.如何进行跨域配置？
1. JSONP
2. CORS
3. webpack实现代理
- ##### JSONP（JSON with Padding）是一种跨域解决方案，它利用 \<script> 标签可以跨域加载资源的特性来实现跨域请求。
- JSONP的实现步骤：
	- 在客户端创建一个\<script> 标签，将请求的 URL 和一个回调函数名作为参数传递给服务器；
	- 服务器接收到请求后，将数据包装在回调函数中返回给客户端；
	- 客户端接收到响应后，调用回调函数处理数据。
-  JSONP 的优点
	- 兼容性好，可以在各种浏览器中使用，但是只支持 GET 请求，不支持 POST 等其他请求方式。
-  ##### CORS（Cross-Origin Resource Sharing）是一种官方的跨域解决方案，它通过在服务器端设置响应头部的一些字段来允许跨域访问。
###### 实现步骤：
- 在服务器端设置响应头部的 Access-Control-Allow-Origin 字段，指定允许跨域访问的域名或通配符 \*；
- 如果需要允许客户端发送带有身份验证信息（如 Cookie、Authorization 等）的请求，需要在服务器端设置响应头部的 Access-Control-Allow-Credentials 字段为 true；
- 如果需要允许客户端发送自定义的请求头部（如 X-Requested-With、Authorization 等），需要在服务器端设置响应头部的 Access-Control-Allow-Headers 字段，指定允许的请求头部；
- 如果需要允许客户端发送自定义的请求方法（如 PUT、DELETE 等），需要在服务器端设置响应头部的 Access-Control-Allow-Methods 字段，指定允许的请求方法。
###### CORS 的优点
- 支持各种请求方式和请求头部，但是需要服务器端支持，而且需要浏览器支持。
#### 77.vue在路由完全进入之前，这时this不存在，这时怎么调用和赋值？
- 可以用路由导航守卫，beforeRouteEnter 。在 beforeRouteEnter 导航守卫中，可以通过 next 回调函数来访问组件实例，该回调函数接收一个参数 vm，表示组件实例。可以在回调函数中对组件实例进行赋值操作。
#### 78.less混入
- 在 Less 中，**可以使用混入（Mixin）来实现样式的复用和组合**。混入类似于函数，**可以接收参数，并且可以在其中定义样式**。
```less
@mixin border-radius($radius){
	border-radius:$radius;
	-webkit-border-radius:$radius;
	-moz-border-radius:$radius;
}
```

#### 79.小程序列表渲染怎么优化，数据下滑的时候数据越来越多，怎么处理
- 分页加载
- 虚拟列表：当列表数据量很大时，可以考虑使用虚拟列表技术，只渲染当前可视区域内的列表项，而不是全部渲染。
- 图片懒加载
- 防抖和节流：当用户下滑列表时，可能会触发频繁的滚动事件，可以使用防抖和节流的技术来减少事件触发的次数，以提高性能。可以使用 lodash 库中的 debounce 和 throttle 方法来实现防抖和节流。
#### 80.在服务器发送请求时，跨域处理流程
- CORS：在服务器端设置响应头，允许跨域访问。例如，可以在响应头中添加Access-Control-Allow-Origin字段，指定允许跨域访问的域名。
#### 81.js数组方法重写——pop、push、shift、unshift、every、some、filter、map、forEach
- pop
	- pop() 方法用于删除数组的最后一个元素，并返回删除的元素。
	- 没有参数，会修改原数组，数组为空时返回 undefined
- push
	- push() 方法可向数组的末尾添加一个或多个元素，并返回新的数组长度。
	- 有参数，会修改原数组。
- shift
	- shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。
	- 没有参数，修改原数组。
- unshift
	- unshift() 方法可向数组的开头添加一个或更多元素，并返回新的数组长度。
	- 有参数，修改原数组。
- every
	- every() 方法使用指定函数检测数组中的所有元素：
	1. 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。
	2. 如果所有元素都满足条件，则返回 true。
- some
	- some() 方法会依次执行数组的每个元素：
	1.  如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。
	2. 如果没有满足条件的元素，则返回 false。
- filter
	- filter() 方法找出满足条件的数组元素，以数组的形式返回。
- map
	- map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
- forEach
	- forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。
#### 82.从宽高、内外边距的角度，说一下块级元素、行内元素、行内块的区别
- 块级元素（\<div>、\<p>、\<h1>）：可以设置宽度、高度、内外边距等属性，会独占一行。
- 行内元素（\<a>、\<span>、\<em>、\<img>）：不能设置宽度、高度等属性，会在一行内按照从左到右的顺序排列。
- 行内块元素（\<input>、\<button>、\<select>）：可以设置宽度、高度、内外边距等属性，会在一行内排列。
#### 83.history会有个问题，刷新时不请求服务器(出现404)，怎么解决？
-  在vue.config.js文件
	- devServer属性里配置historyApiFallback为true
```javascript
{
    devServer:{      
        historyApiFallback: true
    }
}
```
#### 84.清除浮动的三种方式
1. 使用空元素
	- 在浮动元素后面添加一个空元素，并设置clear属性为both，来清除浮动。
	- 然后在需要清除浮动的元素上添加clearfix类即可。	
```css
.clearfix::after{
	content:"";
	display:block;
	clear:both;
}
```
2. 使用overflow属性清除浮动
	- 可以在浮动元素的父元素上设置overflow属性为hidden或auto，来清除浮动。
```css
.parent{
	overflow:hidden;
}
```
3. 使用flex布局清除浮动
	- 可以使用flex布局来清除浮动，将父元素设置为flex容器，然后将子元素设置为flex项目，这样就可以自动清除浮动。
```css
.parent{
	display:flex;
	flex-wrap:wrap;
}
.clild{
	flex:1;
}
```
#### 85.无论promise是成功还是失败都想执行操作该怎么做？
- finally无论成功或失败都执行
#### 86.两个promise想要同步执行的方法？（说两种及以上）
1. 使用Promise.all()方法
	- Promise.all()方法接收一个Promise数组作为参数，当所有Promise都成功地完成时，它将返回一个新的Promise，该Promise的结果是一个包含所有完成值的数组。如果任何一个Promise失败，Promise.all()将立即拒绝，返回失败的原因。
2. 使用async/await语法
	- async/await语法允许我们以同步的方式编写异步代码。要实现两个Promise同步执行，可以在async函数中使用await关键字等待每个Promise完成。
#### 87.什么是async/await？
- async/await是一种异步编程的方式，它可以让我们以同步的方式编写异步代码。async函数是一个异步函数，它可以包含多个异步操作，每个异步操作都可以使用await关键字等待其完成。await关键字只能在async函数中使用，它可以暂停异步函数的执行，等待一个Promise对象的完成，并返回Promise对象的结果。最后，async函数将返回一个Promise对象，该对象的结果是最后一个异步操作的结果。
#### 88.了解过IIFE吗？
- IIFE（Immediately Invoked Function Expression）是一种JavaScript函数的编写方式，它可以**立即执行函数并返回结果。**
- IIFE通常使用匿名函数来定义，然后使用一对括号将其包裹起来，并在末尾添加另一个括号来立即调用该函数。这样，函数将在定义后立即执行，并且不会在全局作用域中创建任何变量。
```javascript
(function(){
	var message='hello world';
	consloe.log(message)
})();
```
#### 89.如何隐藏一个元素
- display：none
- visibility：hidden
#### 90.前端如何减轻后端压力
1. 使用浏览器缓存（如localStorage、sessionStorage或IndexedDB）存储数据，减少对后端的请求。
2. 前端验证：在提交表单或发送请求之前，对用户输入进行前端验证，减少无效请求发送到后端。
3. 分页和懒加载：对于大量数据的展示，使用分页或懒加载技术，按需加载数据，减少一次性请求大量数据的压力。
4. 防抖和节流：对于频繁触发的事件（如滚动、输入等），使用防抖（debounce）或节流（throttle）技术，减少发送给后端的请求次数。
#### 91.Generator的原理
‌‌‌　　Generator是ES6中引入的一种新的函数类型，**它可以在函数执行过程中暂停执行，并在需要时恢复执行**。Generator函数通过function\*关键字定义，可以使用yield关键字暂停函数执行，并返回一个值。当再次调用Generator函数时，它会从上次暂停的位置继续执行，直到函数执行完毕或遇到新的yield语句。
#### 92.css画三角形

```html
<div class="triangle"></div>
```

```css
.triangle {
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-bottom: 100px solid #000;
 }
```

#### 93.BFC（块级格式上下文）
- BFC中的元素按照一定的规则进行布局，不会影响到BFC外部的元素，同时也不会受到外部元素的影响。
- 可以理解成元素的一个“特异功能”。
1. 该 “特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该“特异功能”被激活。
2. 所谓激活“特异功能”，专业点说就是：该元素创建了 BFC （又称：开启了 BFC ）。
- 开启了BFC能解决什么问题
	1. 元素开启 BFC 后，其子元素不会再产生 margin 塌陷问题。
	2. 元素开启 BFC 后，自己不会被其他浮动元素所覆盖。
	3. 元素开启 BFC 后，就算其子元素浮动，元素自身高度也不会塌陷。
- 如何开启BFC
	1. 根元素
	2. 浮动元素
	3. 绝对定位、固定定位的元素
	4. 行内块元素
#### 94.get和post区别
- 请求参数：GET请求会将请求参数附加在URL的末尾，而POST请求则将请求参数放在请求体中。
- 参数长度：GET请求的请求参数有长度限制，通常为2048个字符，而POST请求的请求参数长度没有限制。
- 缓存：GET请求可以被缓存，而POST请求不能被缓存。
- 用途：GET请求通常用于获取资源，而POST请求通常用于提交数据。
#### 95.JavaScript对象数组去重
1. 使用filter和Map  
2. 使用reduce 
#### 96.dispaly:none、visibility:hidden和opacity:0的区别
###### display: none;
- DOM 结构：浏览器不会渲染 display 属性为 none 的元素，不占据空间；
- 事件监听：无法进行 DOM 事件监听；
- 性能：动态改变此属性时会引起重排，性能较差；
- 继承：不会被子元素继承，毕竟子类也不会被渲染；
- transition：transition 不支持 display。
###### visibility: hidden;
- DOM 结构：元素被隐藏，但是会被渲染不会消失，占据空间；
- 事件监听：无法进行 DOM 事件监听；
- 性 能：动态改变此属性时会引起重绘，性能较高；
- 继 承：会被子元素继承，子元素可以通过设置 visibility: visible; 来取消隐藏；
- transition：visibility 会立即显示，隐藏时会延时
###### opacity: 0;
- DOM 结构：透明度为 100%，元素隐藏，占据空间；
- 事件监听：可以进行 DOM 事件监听；
- 性 能：提升为合成层，不会触发重绘，性能较高；
- 继 承：会被子元素继承,且，子元素并不能通过 opacity: 1 来取消隐藏；
- transition：opacity 可以延时显示和隐藏

1. display:none：元素不会被渲染，也不会占据空间。使元素设置了宽度和高度，也不会显示出来。display:none会使元素从文档流中移除，因此对布局产生影响。
2. visibility:hidden：元素不会被渲染，但会占据空间。即使元素设置了宽度和高度，也不会显示出来。visibility:hidden不会使元素从文档流中移除，因此对布局不会产生影响。
3. opacity:0：元素会被渲染，但是完透明，不会显示出来。元素仍然占据空间，因此对布局会产生影响。

因此，如果您想完全隐藏一个元素并且不影响布局，可以使用display:none。如果您想隐藏一个元素但仍然保留其占用的空间，可以使用visibility:hidden。如果您想隐藏一个元素但仍然保留其占用的空间，并且希望在某些情况下可以通过JavaScript来控制其显示和隐藏，可以使用opacity:0。
#### 97.js延迟加载的几种方式？
1. defer属性：当页面已完成加载后，才会执行脚本。
2. async属性：一旦脚本加载完成，则会立即执行。
3. 动态加载：使用 JavaScript 动态创建 \<script> 标签，并将其添加到文档中，可以在需要时加载脚本。这种方式适用于需要根据用户行为或其他条件来加载脚本的情况。
4. setTimeout ( ) : 可以使用 setTimeout() 函数延迟加载某个 JavaScript 文件或者图片等资源。
#### 98.[重绘和回流](https://juejin.cn/post/6844903569087266823)
- 重绘：
	- 当元素样式的改变不影响它在文档流中的位置时，浏览器会将新样式绘制到屏幕上，这个过程叫做重绘。重绘不会影响元素的布局和位置，因此它的代价比较小。

- 回流：
	- 当元素的尺寸、布局、内容或者某些属性发生改变时，浏览器需要重新计算元素的何属性（例如位置、大小等），然后再将其绘制到屏幕上，这个过程叫做回流。回流会导其他元素的尺寸、位置等属性发生改变，因此它的代价比较大。
#### 99.sass、less和css的区别
1. 语法：Sass 和 Less 都是 CSS 预处理器，它们提供了比 CSS 更加强大的语法和功能。Sass 使用缩进式语法，而 Less 使用类似 CSS 的语法。CSS 是一种标准的样式表语言，它没有预处理器的功能。
2. 变量：Sass 和 Less 都支持变量，可以在样式表中定义变量，然后在其他地方使用。CSS 不支持变量。
3. 嵌套规则：Sass 和 Less 都支持嵌套规则，可以将子元素的样式嵌套在父元素的样式中。CSS 不支持嵌套规则。
4. 混合（Mixin）：Sass 和 Less 都支持混合，可以将一组样式定义为一个混合，然后在其他地方使用。CSS 不支持混合。
5. 继承：Sass 支持继承，可以将一个选择器的样式继承到另一个选择器中。Less 不支持继承。CSS 也不支持继承。
6. 函数：Sass 和 Less 都支持函数，可以在样式表中定义函数，然后在其他地方使用。CSS 不支持函数。
7. 导入：Sass 和 Less 都支持导入其他样式表，可以将多个样式表合并成一个。CSS 不支持导入。
#### 100.解构的失效会拿到什么值
- 如果解构赋值失败，变量将会被赋值为 undefined。
#### 101.如何销毁变量
- 变量的销毁是由垃圾回收机制自动处理的。当一个变量不再被引用时，垃圾回收机制会自动将其标记为可回收的，等待下一次垃圾回收时被回收。
#### 102.普通盒模型和标弹性模型有什么区别？弹性盒模型常用属性？flex=1,代表什么意思？改变主轴反向是那个属性？
- 普通盒模型：元素的宽度和高度固定，无法根据容器的大小自适应调整。
- 弹性盒模型：弹性盒子是一种可以自适应调整大小和位置的容器，可以根据容器的大小和内容的大小自动调整元素的位置和大小。
###### 弹性盒模型常用属性包括：
- display: flex;：将元素设置为弹性盒子
- flex-direction：设置主轴的方向
- justify-content：设置主轴上的对齐方式
- align-content：设置多行的对齐方式
- flex=1 表示元素的伸缩比例为1，即元素可以根据剩余空间自动分配宽度或高度。
- 改变主轴反向的属性是 flex-direction
#### 103.pc端如何做[适配](https://blog.csdn.net/weixin_42754922/article/details/128157035)?插件需要做哪些配置？具体的配置属性有哪些？按照几倍比例做适配？
1. 使用百分比或者 em/rem 单位进行布局，这样可以根据浏览器窗口大小自适应调整布局。
2. 使用 CSS3 的媒体查询（Media Query）来根据不同的屏幕分辨率设置不同的样式。
3. 使用 CSS3 的 Flexbox 布局来实现弹性布局，可以根据容器的大小自适应调整布局。
4. 使用 CSS3 的 Grid 布局来实现网格布局，可以根据容器的大小自适应调整布局
 - **使用插件lib-flexible **:
	- 在进行适配时，可以按照设计稿的比例来进行适配。
	- 设计稿的宽度为 1920px，可以按照 1:1 的比例进行适配，即将浏览器窗口的宽度设置为 1920px。
	- 设计稿的宽度为 1440px，可以按照 3:4 的比例进行适配，即将浏览器窗口的宽度设置为 1080px。
#### 104.[promise](https://zh.javascript.info/promise-basics)说一下？promise.all和promise.race有什么区别？promise的pendding状态可以修改值吗？
- ###### promise是什么？
	- Promise 是一种异步编程的解决方案，用于处理异步操作和回调函数的问题。它可以将异步操转换为同步操作，使得代码更加简洁和易于理解。
	- Promise 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。
- ###### promise.all和promise.race有什么区别？
	- Promise.all : 在所有异步操作执行完后才执行回调
	- Promise.race : 方法与all正好相反谁最先执行完成，就以谁为准执行回调。
- ###### promise的pendding状态可以修改值吗？
	- 不可以修改
- ###### promise是什么任务？
	- 微任务
#### 105.async和promise有什么不同？
- async和promise都是异步方法，区别是async生成的结果是promise对象，async是promise的终结版。
- await只能在async中使用，await是阻塞的意思，就是暂停，你一起调用2个接口，第一个执行完，不输出结果，要等第二个接口执行完，才返回这两个的结果。
#### 106.什么是闭包？如何手动清除函数？递归是闭包吗？
- 闭包是能够读取其他函数内部变量的函数。
- 如何手动清除函数？
	- 把函数置空，myFunction = null;
- 递归也是一种闭包
#### 107.setTimeout是什么任务？nextTick是什么任务？nextTick先执行还是promise先执行？
**setTimeout 是宏任务，nextTick是宏任务**
- nextTick先执行还是promise先执行？
	- Vue2中nextTick先执行，后执行promise
	- Vue3与vue2相反
#### 108.如何在挂载前去拿数据或结点？nextTick的原理是什么？nextTick是js加载后执行还是js加载前执行
- 使用异步函数或 Promise 来获取数据或节点
- nextTick的原理利用了浏览器的异步队列机制，将回调函数推入到异步队列中，在 DOM 更新完成后执行回调函数。
- nextTick是等js加载完成后才执行
#### 109.vue的data为什么是一个函数不是一个对象？为什么vue要是用异步渲染？
- Vue组件可以同时存在多个实例，如果直接使用对象形式的data选项，那么所有的实例将会共享同一个data对象，这样就会造成数据互相干扰的问题。
- Vue 之所以使用异步渲染，是为了提高渲染性能和用户体验。
#### 110.说一下apply和call 的区别？
- 传递参数不同
	- call 方法是将参数依次列举出来，用逗号分隔
	- apply 方法是将参数放在一个数组或类数组对象中
#### 111.hash模式和history模式的区别？
###### hash模式
1. 地址中永远带着#号，不美观 。
2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。
3. 兼容性较好。
###### history模式：
1. 地址干净，美观 。
2. 兼容性和hash模式相比略差。
3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。
###### history你是如何做配置的？
- 首先要将mode设置为history；然后后端用nginx配置

#### 112.什么是前置路由守卫？什么是后置路由守卫？用在哪里？怎么用？有什么配置？
###### 前置路由守卫
- 语法：router.beforeEach((to, from, next) => {这里可以写路径的跳转判断/有无token值的情况分析})
- 参数：to : 到哪里去
	- from : 从哪里来
	- next : 放行函数 next():放行 , next(false):不放行
- 作用：检查是否符合跳转条件，检查用户是否登录了
###### 后置路由守卫
- 语法：router.afterEach((to,from)=>{})
- 参数：to : 到哪里去
	- from : 从哪里来
- 作用：跳转到点击的路由组件后，再进行一些调整，比如给路由组件起标题

#### 113.[自定义指令](https://blog.csdn.net/weixin_66557048/article/details/129579472)怎么使用？常用在哪里？
- 自定义指令：
	- 全局注册：通过Vue.directive方法进行注册
		- 参数：
			- 第一个参数：指令的名字（不需要写上v-前缀）
			- 第二个参数：对象或者指令函数
```javascript
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能
  }
})
```

- 局部注册：通过在组件options选项中设置directive属性
```javascript
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
    }
  }
}
```
- 应用场景：
	1. 防止表单重复提交
	2. 图片懒加载
	3. 一键 Copy的功能

#### 114.登录怎么做的？做过[第三方登录](https://juejin.cn/post/7074156327957692429)吗？如何做登录加密的？
1. 首先登录，登录成功后，后端会返回给我们一个token和我们其他路由、菜单、权限数据。
2. 把这些数据存储到vuex里面
3. 在axios拦截器里的config里配置token，保证需要登录验证的接口能拿到token
4. 当在beforeEach的时候使用router.addRoute()进行一个动态路由的加载并且做404页面的匹配。
5. 菜单在进入首页的时候通过获取vuex的菜单数据，渲染菜单
#### 115.本地缓存有哪些？有啥区别？通常什么情况下会使用？
1. 存储空间：cookie存储空间最小、只有4kb、但是http请求中可以携带cookie，localstorage、sessionstorage存储空间5m或更大
2. 有效期：cookie不设置时间、关闭浏览器销毁，sessionstorage关闭浏览器（窗口或者标签页）销毁，loacalstorage不手动清除一直保留
3. 作用域：sessionStorage不在不同浏览器窗口（标签页）共享、即使同源，cookie、localstorage在所有同源窗口之间共享
- 应用场景：
	- cookie：请求时会自动携带,最合适的就是通过发送请求的时候做权限验证
	- localStorage：关闭浏览器不会清除,适用于存储一些不变的数据,
	- sessionStorage：关闭浏览器会清除数据,用于一些较为敏感的数据
#### 116.webpack常用配置项？一一列举说明?
- **entry（入口）**指示 Webpack 从哪个文件开始打包
- **output（输出）**指示 Webpack 打包完的文件输出到哪里去，如何命名等
- **loader（加载器）**webpack 本身只能处理 js、json 等资源，其他资源需要借助 loader，Webpack 才能解析
- **plugins（插件）**
- **mode（模式）**
#### 117.vue是单页面应用，会导致首屏渲染速率很慢？如何解决？[[#19. 了解哪些 Vue 的性能优化方法？]][[#20. Vue项目性能优化？]]
- 减小入口文件体积、UI框架按需加载、图片资源的压缩、组件重复打包、开启GZip压缩
- ![[Pasted image 20230608214759.png]]

#### 118.[项目里面的权限是怎么做的？](https://vue3js.cn/interview/vue/permission.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)
#### 119.手写过原生http请求吗？
```html
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>原生Http请求服务</title>
</head>
<body>
	<div>一个测试http</div>
	<script src="main.js" type="text/javascript" charset="utf-8"></script>
</body>
</html>
```
```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET',"http://192.168.1.1/checkCompanyName/123".true);
xhr.send();
xhr.onreadystatechange = function(){
	//这步为判断服务器是否正确相应
	if(xhr.readyState == 4 && xhr.status == 200){
	console.log(xhr.responseText)}
}
```
	
#### 120.delete请求说一下？有遇到过post用data传数据吗？怎么封装的？
- DELETE请求方法用于请求服务器删除指定的资源。

#### 121.Echars用过什么图像？具体怎么使用的？
- 饼图
```javascript
option = {
  series: [
    {
      type: 'pie',
      stillShowZeroSum: false,
      label: {
        show: false
      },
      data: [
        {
          value: 0,
          name: '直接访问'
        },
        {
          value: 0,
          name: '联盟广告'
        },
        {
          value: 0,
          name: '搜索引擎'
        }
      ]
    }
  ]
};
```

#### 122.项目中样式用的less还是sass有什么区别？
- Less和Sass的主要不同就是他们的实现方式。
- Less是基于JavaScript，是在客户端处理的。
- Sass是基于Ruby的，是在服务器端处理的。
- 关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。

#### 123.说一下原型链?继承有几种方式？实现继承有几个步骤？
- 原型：每个函数都有prototype属性称之为原型
	- 原型可以放一下属性和方法，共享给实例对象使用
	- 原型可以继承
- 原型链：
	- 对象都有_proto_属性，这个属性指向它的原型对象，原型对象也是对象，也有_proto_属性，指向原型对象的原型对象，这也一层层形成的链式结构成为原型链，最顶层也找不到则返回null
	
	
![[Pasted image 20230519172853.png]] 

- 继承有几种方式？
	6种
	1. 原型链继承
	2. 借用构造函数
	3. 组合继承
	4. 原型式继承
	5. 寄生继承
	6. 寄生组合继承
- 实现继承的步骤？
	- 父类实例对象等于子类原型
	- 借用构造函数
	- 原型式继承（一个继承父类原型的新对象，替换父类实例对象）
- 创建父对象和子对象并将父对象作为原型对象、在子对象中定义自己的属性和方法，通过子对象访问属性或方法。

#### 124.forEach和map说一下区别？谁会改变原数组？谁会返回新数组？
- map()会分配内存空间存储新数组并返回，forEach()不会返回数据。
- forEach()会修改原来的数组，而map()方法会返回一个新数组。

#### 125.pdf预览用的什么插件？
1. PDF.js：一个开源的JavaScript库，可以在浏览器中直接显示PDF文档。
2. pdfobject：一个简单的JavaScript库，可以在页面中嵌入PDF。
3. Mozilla's PDF.js：Mozilla开发的PDF.js是一个基于HTML5的PDF阅读器，可以在浏览器中直接显示PDF文档。
4. ViewerJS：一个开源的JavaScript库，可以在浏览器中直接显示PDF、OpenOffice、Microsoft Office等多种文档格式。
- 使用插件vue-pdf进行预览
- 单页pdf可以直接使用
```html
<pdf>
	:src="获取的pdf地址"
</pdf>
```
- 多页pdf通过循环实现
```html
<pdf>
	v-for="item in pageTotal"
	:src="pdfUrl"
	:key="item"
	:page="item"
</pdf>
```
- 在mounted函数中，需要调用下述方法，获取pdf的总页数
```javascript
// 获取pdf总页数
getTotal(){
	// 多页pdf的src中不能直接使用后端获取的pdf地址，否则会按页数请求多次数据
	// 需要使用下述方法的返回值作为url
	this.pdfUrl = pdf.createLoadingTask('获取pdf地址')
	// 获取页码
	this.pdfUrl.promise.then(pdf => this.pageTotal = pdf.numPages).catch(error=>{})
}
```

#### 126.如何给静态资源加速？
1. **使用浏览器缓存**可以将静态资源缓存到本地
2. **DNS预解析**：DNS预解析是一种技术手段，它可以在页面加载时预先解析页面中的链接，从而加速页面的加载速度。可以通过在页面中添加\<link rel="dns-prefetch" href="//example.com">标签来实现DNS预解析。
3. **CDN加速**：CDN（Content Delivery Network）是一种分布式的网络架构，它可以将静态资源缓存到全球各地的服务器上，从而实现就近访问，提高资源的加载速度。使用CDN加速可以有效地减少网络延迟和带宽消耗，提高网站的性能和可用性。
4. **压缩和合并**：将多个CSS或JavaScript文件合并成一个文件，并使用压缩算法对文件进行压缩，可以减少文件的大小，从而提高文件的加载速度。此外，还可以使用图片压缩算法对图片进行压缩，减少图片的大小，从而提高图片的加载速度。

#### 127.图片懒加载
1. vue-lazyload插件可以实现
2. IntersectionObserver是一个api可以实现
	-  在src目录下建立一个directives的文件夹，在其中建立lazy.js
	-  在main.js中注册并加载
```javascript
export default {
	mounted(el){
		const imgSrc = el.src
		el.src=''
		// 观察者IntersectionObserver是一个api
		const observer = new IntersectionObserver((({isIntersecting}))=>{
			console.log('触发了')
			// 元素出现在可视区域，和离开区域时触发
			if(isIntersecting){
				// 加载图片
				el.src = imgSrc
				// 停止观察（停止加载图片时每次触发）
				observer.unserve()
			}
		})
		observer.observer(el)
	}
}
```

#### 128. 垂直居中
1. 使用绝对定位和transform
```css
#box {
    width: 300px;
    height: 300px;
    background: #ddd;
    position: relative;
}
#child {
    background: orange;
    position: absolute;
    top: 50%;
    transform: translate(0, -50%);
}
```
2. 父容器开启 flex 布局，随后使用 justify-content 和 align-items 实现水平垂直居中
```css
.outer {
	width: 400px;
	height: 400px;
	background-color: #888;
	display: flex;
	justify-content: center;
	align-items: center;
}
.inner {
	width: 100px;
	height: 100px;
	background-color: orange;
}
```
3. 位移配合定位，可实现元素水平垂直居中
```css
.box { 
	position: absolute;
	left: 50%; 
	top: 50%; 
	transform: translate(-50%, -50%);
}
```
4. 父容器开启 flex 布局，随后子元素 margin: auto
```css
.outer { 
	width: 400px; 
	height: 400px; 
	background-color: #888; 
	display: flex; 
} 
.inner { 
	width: 100px; 
	height: 100px; 
	background-color: orange; 
	margin: auto; 
}
```
#### 129.[前端的安全性问题](https://blog.csdn.net/qq_40409143/article/details/115286003)
1. XSS（Cross-Site Scripting）脚本攻击漏洞
	- 通过在你的输入文本当中或者这HTML标签当中插入js脚本进行攻击，在每次打开网页的时候就会执行该脚本。
	- 解决方法：
		- XSS攻击其核心都是利用了脚本注入，因此我们解决办法其实很简单，不信赖用户输入，对特殊字符如”<”,”>”转义，就可以从根本上防止这一问题。
2. CSRF（Cross-sit request forgery）漏洞
	- CSRF也称为跨站请求伪造，其实就是对网站中的一些表单提交行为被黑客利用。比如你的网站登录的时候存到cookie的一些个人信息，当你访问黑客的网站有一段相同代码隐藏div，但你点击的时候就会导致你的网站被登出或者被登录，就是在对别的网站就行操作的时候会对你之前访问的网站发送请求。
	- 解决方法：
		1. 进行二次验证，在进行敏感数据操作时，要求用户进行二次验证，减少风险
		2. 在表单中增加一个hidden隐藏字段，用来提交token，并在服务器检查token是否正确
		3. 验证 HTTP Referer 字段
		4. 在http头中加入自定义的属性，在服务器进行验证
		5. 避免使用GET，使用POST请求方式
3. SQL注入攻击
	- SQL注入(SQL Injection)，应用程序在向后台数据库传递SQL(Structured Query Language，结构化查询语言)时，攻击者将SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
#### 130.垃圾回收机制
1. JavaScript 中的**垃圾回收机制是自动的，它会定期检查不再使用的变量和对象，并释放它们所占用的内存。**JavaScript 引擎使用的垃圾回收算法是**标记清除算法**和**引用计数算法**。
2. 标记清除算法是 通过标记所有活动对象，然后清除所有未标记的对象。在 JavaScript 中，垃圾回收器会从全局对象开始，递归遍历所有对象，并标记所有可达对象。然后，它会清除所有未标记的对象，并释放它们所占用的内存。
3. 引用计数算法是跟踪每个对象被引用的次数。当对象被引用时，它的引用计数加 1；当对象不再被引用时，它的引用计数减 1。当对象的引用计数为 0 时，它就可以被垃圾回收器回收。在 JavaScript 中，引用计数算法的实现比较简单，但是它无法处理循环引用的情况，因此在实际应用中很少使用。
#### 131.vue2与vue3的区别
1. 性能的提升：打包大小减少了，渲染更快了，内存减少了
2. 源码的升级：
	- 使用Proxy代替defineProperty实现响应式
	- 重写虚拟DOM的实现和Tree-Shaking
3. 支持TypeScript
4. 新的特性:
	 1. Composition API（组合API）
		- setup配置
		- ref与reactive
		- watch与watchEffect
		- provide与inject
	2. 新的内置组件
	    - Fragment
	    - Teleport
	    - Suspense
	3. 其他改变
	    - 新的生命周期钩子
	    - data 选项应始终被声明为一个函数
	    - 移除keyCode支持作为 v-on 的修饰符
